#+STARTUP: hideblocks
* [2021-05-30 Sun 17:17] emacs config                                  :info:
  :PROPERTIES:
  :CUSTOM_ID: node-2021-05-30-17-17
  :ID:       node-2021-05-30-17-17
  :END:

  因为经常要用到 emacs ，比如说 org-mode 来记笔记，但是，当前的 emacs 配置
  又不是很满意，需要持续不断的改进，这个工作的主要目的是改善 emacs 的友好性，
  起码对我来说要是友好的。

  从网上学看到了 [[id:node-2021-06-07-10-03][literate programming 方法做的]] emacs 配置，根据 github 上
  的配置，初步完成了当前的 ~conf.org~ 文件。后续工作主要是继续完善这个文
  件。

** plan

   user-friendly 是个很难定义的东西啊，不同人是不一样的，即使是同一个人，在
   不同时间点，对于 user-friendly 这个概念的要求也可能是不一样的。只能说持
   续改进吧，保证在不同时间段的使用过程中都能满足使用需求。

   最近想做的事：
   - 将平时用到的配置移到这个文件里来, add ido and wubi input method
   - 看怎么将字体添加到 emacs.d 的文件夹里，让 emacs 用它自己的字体，linux
     上的字体太丑了
   - 用好 ggtags ，看它哪个功能不爽了，按自己的想法改成自己想用的方式
   - 除了 clangd/ccls 这两个 language server 就没有其他的 c/c++ language
     server 嘛？浪费了四天时间配置 emacs 的 lsp ，但是都因为种原因失败了，
     language server
   - python 的 lsp 配置，暂时用 elpy 做开发
   - 看有没有办法解决多个包含 '_ARCHIVE_' 的 org 文件合并时，产生多个
     '_ARCHIVE_' 条目的问题。
   - use a collection of tools to find fils: `find-file-in-project',
     `orderless' and `vertico'. `find-file-in-project' could be used to
     find all matched files in the `project', which is a directory with
     `.dir-local-vars' file. `orderless' is responsible for enhancing
     completion system. And `vertico' provides a vertical completion UI.

** reivew

   首先，要创建 ~$(HOME)/.emacs.d~ 这个文件夹，并将 ~conf.org~ 文件放到这个
   文件夹中，用 emacs 打开并运行 ~org-babel-tangle~ ， ~.emacs.d~ 文件夹内
   便会生成 ~init.el~ 和 ~conf.el~ 文件。

   当前已经完成 ~package~ 包的安装，其实最一开始要配置的应该是 emacs 的
   default preference，然后将 `packages' 的 bug 修了，再接上剩余的配置。

   先加上代码注释吧，即使有 org 文件作为说明，加上注释的代码可能更好看一点。

   发现一件事，对我而言，用 literate programming 写代码还是有些困难的，要考
   虑怎么把代码 tangle up ，要安排代码的顺序，最后还是逃不过代码调试，而且
   无形中增加了工作量，可能是对 elisp 代码不熟导致的。

   已经将 org mode 的配置移入到这个 org 文件中了，剩下的先从 color theme 开
   始做吧，emacs 自带的 theme 在 终端上显示时有些文字都看不清。

   configured zenburn theme to be the default theme.

   需要将 src structure template 中所有 'elisp' 改为 'emacs-lisp'，因为
   `org-babel-load-file' 这个函数会使用 `org-babel-tangle-file' 这个函数将
   loaded file 中的 src code 进行 tangle 操作，并且将 exported source code
   block 限定为 'emacs-lisp'。

   另外，在使用 `org-babel-load-file' 这个函数时，需要加载 `ob-tangle' 这个
   feature，否则会导致 source code block 在 tangle 时，输出文件与期望不一致
   的情况。

* [2021-06-07 Mon 10:03] literate programming
  :PROPERTIES:
  :CUSTOM_ID: node-2021-06-07-10-03
  :ID:       node-2021-06-07-10-03
  :END:

  逛 github 找 emacs 配置文件的时候，发现了一种比较 awesome 的配置：将配置
  写到 org 文件中去，使用 emacs 内置功能，读取这个 org 文件，获取 emacs 的
  配置。一方面，人是可以读取这个 org 文件，另一方面，机器可以获取配置代码片
  段，完成 org 文件中想要实现的配置。

  后面的 emacs configuration 打算按照这个思路去实现。

  The idea is originated from literate programming proposed by Donald Knuth
  in 1984. Found it [[https://github.com/alhassy/emacs.d][here]]. In his [[https://github.com/alhassy/emacs.d/blob/master/init.org][init.org]] file, there is a link point to
  [[https://leanpub.com/lit-config/read][literate programming]] and [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][introduction to lierate programming]].
* [2021-06-07 Mon 19:24] emacs init 文件
  :PROPERTIES:
  :CUSTOM_ID: node-2021-06-07-19-24
  :ID:       node-2021-06-07-19-24
  :END:

  如果是要把配置文件写入到 org 文件中，应该是要有方法把它从 org 文件中
  weaver 出来的。需要怎么样在 org 文件中标记哪些是 emacs 启动的配置文件呢？

  首先，假设这个文件已经在 ~$(HOME)/.emacs.d~ 文件夹中了。

** org-babel header argument 相关的配置

   org-babel header argument 的相关说明参考：[[https://org-babel.readthedocs.io/en/latest/header-args][org-babbel 使用说明]]。

   这个配置文件有两个功能：
   - 生成 `init.el'
   - 加载其他配置

   生成 `init.el' 文件的那些 code block 不应该在 `org-babel-load-file' 时运
   行，因此 header argument 里要对 `init.el' 中的 code block 设置 ~:noeval~

** 使用 org-babel 设置 init.el 文件，让 org 文件输出 init.el
   :PROPERTIES:
   :header-args: :tangle no
   :END:

   在 emacs 初始化的时候将 garbage collecting 设成一个很大的値，初始化完成
   之后再恢复。

   这里比较难受的点是，org-babel 说明书上说 header arguments 的继承关系是
   default -> language-specific -> buffer -> subtree -> code block -> call
   line ，但是 subtree 上添加 header arguments 的 properties 还是没法在运行
   `org-babel-load-file' 时，cann't tangle up the code blocks in subtrees
   which has ~:tangle yes~ property. Unless you open the conf.org file, and
   run the command `org-babel-tangle' inside emacs.

   there is a startup error complaining about non-existence of
   ~old-gc-threshold~ if it is not create on top of the =init.el= file. The
   problem is caused by [[https://www.emacswiki.org/emacs/DynamicBindingVsLexicalBinding][dynamic binding]]. We need to use lexical binding
   when adding ~gc-cons-threshold~ resetting function to ~after-init-hook~.

   #+begin_src emacs-lisp :noweb-ref init-gc :noeval
     ;; enlarge garbage collection threshold to accelerate init process, reset
     ;; the value after init

     ;; use lexical-binding here
     (let ((old-gc-threshold gc-cons-threshold))
       (setq gc-cons-threshold (* 10000 10000))
       (add-hook 'after-init-hook
         (lambda() (setq gc-cons-threshold old-gc-threshold))))
   #+end_src

   为了避免每次修改都要手动去运行 org-babel-tangle 相关的命令，添加一个
   hook，让它自己去执行 tangle 和 byte-compile 相关的操作，参考自[[https://github.com/larstvei/dot-emacs][这位]]的配置
   文件。因为下面的自动化操作会涉及到 org ，这里先加载 org。

   #+begin_src emacs-lisp :noweb-ref init-tangle :noeval
     ;; setup a handy after-save-hook for future config update
     (defun mel/tangle-init ()
       "tangle init code block in 'conf.org', and byte-compile the
     tangled file."

       (when (equal (buffer-file-name)
                    (file-truename
                     (expand-file-name (concat user-emacs-directory "conf.org"))))
         ;; require org first, 'cause we need to use org to tangle up the init
         ;; and config code
         (unless (and (featurep 'org) (featurep 'ob-tangle))
           (require 'org)
           (require 'ob-tangle))
         ;; run without any unnecessary prog-mode hooks
         (let ((prog-mode-hook nil))
           (org-babel-tangle)
           (byte-compile-file (concat user-emacs-directory "init.el")))))

     (add-hook 'after-save-hook 'mel/tangle-init)
   #+end_src

   init 里好像也没有其他事要办了，那就加载 `conf.org' 文件吧~ one more
   thing to notice, we need to specify lexical binding to reset garbage
   collection threshold. Set file local variable ~lexical-binding~ to ~t~
   in the file header.

   #+begin_src emacs-lisp :noweb-ref init-load-conf :noeval
     ;; load config file
     (let ((conf-org-file (expand-file-name "conf.org" user-emacs-directory))
           (conf-file (expand-file-name "conf.el" user-emacs-directory)))
       (cond
        ((file-exists-p conf-file)
         (load-file conf-file))
        ((file-exists-p conf-org-file)
         (unless (and (featurep 'org) (featurep 'ob-tangle))
           (require 'org)
           (require 'ob-tangle))
         (org-babel-load-file conf-org-file))
        (t (message "config file 'conf.el' or 'conf.org' NOT FOUND in %s"
                    user-emacs-directory))))
   #+end_src

   init.el looks like:

   #+begin_src emacs-lisp :tangle init.el :noweb tangle :noeval
     ;; -*- lexical-binding: t -*-

     <<init-gc>>

     <<init-tangle>>

     <<init-load-conf>>

     <<init-load-ongoing>>

     ;; init.el ends here
   #+end_src

** 解决路径中包含链接时 tangle-init 不工作问题
   buffer-file-name 使用的是文件的起初路径，当 conf.org 所在路径中有链接
   时，需要使用 file-truename 显示文件的真实路径。
* [2021-06-07 Mon 18:24] 使用 ~org-babel-load-file~ 加载其他配置文件
   :PROPERTIES:
   :header-args: :tangle no
   :END:

  因为 org-bable-load-file 的操作过程是先将 org 文件 tangle 出来，得到 el
  script，再运行这个 el script，因此，所有与 init 无关的 code block 都要加
  上 ~:tangle yes~ 这个 header-args，为了方便操作，直接在这个 headline 上
  加上 header-args 相关的 property：

  #+begin_example
    :header-args: :tangle yes
  #+end_example

** 这里是整个 conf.el 的样子

   #+begin_src emacs-lisp :tangle yes :noweb strip-export
     <<pref>>
     <<pref-el>>
     <<pref-ro>>
     <<pkg-bug>>
     <<pkg>>
     <<autoload>>
     <<pkg-use-package>>
     <<cfg-no-litter>>
     <<cfg-built-in>>
     <<cfg-org>>
    #+end_src

** 使用 package 作为包管理器

    #+begin_src emacs-lisp :noweb-ref pkg

      (require 'package)
    #+end_src

    配置 package 下载路径，不同 emacs 版本对应不同的下载路径。对于 26.1 这个
    版本，还可以配置 `package-gnupghome-dir' 这个文件夹。

    #+begin_src emacs-lisp :noweb-ref pkg

      (let ((versioned-pkg-dirs
             (mel/expand-pkgs-dir
              (format "elpa-%s.%s" emacs-major-version emacs-minor-version))))
        (setq package-user-dir versioned-pkg-dirs)
        (setq package-gnupghome-dir (expand-file-name "gnupg" versioned-pkg-dirs)))
    #+end_src

    package 仓库 `gnu' 与 `melpa'，这里使用网易的镜像。

    #+begin_src emacs-lisp :noweb-ref pkg

      (setq package-archives '(("gnu" . "http://mirrors.ustc.edu.cn/elpa/gnu/")
                               ("melpa-stable" . "http://mirrors.ustc.edu.cn/elpa/melpa-stable/")
                               ("melpa" . "http://mirrors.ustc.edu.cn/elpa/melpa/")))
    #+end_src

    这个配置好像是在哪抄的，忘了具体作用了。

    #+begin_src emacs-lisp :noweb-ref pkg

      (setq package-enable-at-startup nil)
    #+end_src

    添加一个安装 package 的函数

    #+begin_src emacs-lisp :noweb-ref pkg

      (defun mel/require-package (pkg)
        "Install given PACKAGE"
        (condition-case err
            (unless (package-installed-p pkg)
              (package-install pkg))
          (error (message "Couldn't install package: `%s': %S" pkg err) nil)))
    #+end_src

    初始化 package，并更新 package list

    #+begin_src emacs-lisp :noweb-ref pkg

      (package-initialize)

      ;; unconditionally update keyring for all versions
      (when (and (not package-archive-contents)
                 ;; these function are needed at least in versions less than 26.3
                 (version<= emacs-version "26.3"))
        ;; disable signature checking
        (setq package-check-signature nil)
        ;; refresh
        (package-refresh-contents)
        ;; install gnu-elpa-keyring-update
        (mel/require-package 'gnu-elpa-keyring-update)
        ;; set signature checking to default value
        (setq package-check-signature 'allow-unsigned)
        ;; import keyring to versioned-pkg-dirs/gnupg
        (package-import-keyring (expand-file-name "package-keyring.gpg" data-directory))
        ;; update keyring
        (gnu-elpa-keyring-update))
    #+end_src

    因为 26.1 emacs 的 [[https://debbugs.gnu.org/cgi/bugreport.cgi?bug=34341][这个 bug]]，对于 emacs 26.1 需要额外添加一个操作，参考
    自[[https://github.com/syl20bnr/spacemacs/issues/12535][这里]]。

    #+begin_src emacs-lisp :noweb-ref pkg-bug

      (setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")
    #+end_src

** 使用 use-package 管理各个 package 的配置，首先要安装并配置 use-package

    #+begin_src emacs-lisp :noweb-ref pkg-use-package
      (unless (require 'use-package nil t)
          ;; install use-package
          (mel/require-package 'use-package))
    #+end_src
* [2021-06-09 Wed 09:33] 将工作主体移出

  参考网上 literate programming 形式，将配置文件写在 org 文件内部，org 文件
  中说明每个配置的相关信息，[[id:node-2021-06-07-19-24][这里]]已经初步完成了 ~conf.org~ 文件的雏形，剩余
  工作主要是一点点完善这个文件，有空可以将这个工作的主体移出 project 文件了，
  project 文件里只记录这个工作的相关说明。
* [2021-06-26 Sat 21:05] 配置 default
  :PROPERTIES:
  :header-args: :tangle no
  :ID:       node-2021-06-26-21-05
  :END:

  define some handy functions. ~mel/mkdir~ 函数用于创建文件夹。
  ~mel/expand-emacs-d~ 在输入的文件夹之前添加
  ~${HOME}/.emacs.d/~ 。~mel/auto-dir-n-file~ 为保存 emacs 自动生成的文件的
  位置。

  #+begin_src emacs-lisp :noweb-ref pref
    ;; handy function
    (defun mel/mkdir (dir-name)
      "Check if dir-name exists, if not, make a new dir called `dir-name'"
      (unless (file-directory-p dir-name)
        (make-directory (file-name-as-directory dir-name))))

    (defun mel/expand-emacs-d (dir-name)
      "Expand dir name relative to `user-emacs-directory'"
      (file-name-as-directory
       (expand-file-name (convert-standard-filename dir-name)
                         user-emacs-directory)))

    ;; set mel/auto-dir-n-file
    (defvar mel/auto-dir-n-file
      (mel/expand-emacs-d "auto-dir-n-file")
      "The directory where packages place their configuration files")

    ;; create auto-dir-n-file
    (mel/mkdir mel/auto-dir-n-file)

    (defmacro mel/expand-auto-dir (dir-name)
      "Expand dir name relative to `mel/auto-dir-n-file'"
      `(file-name-as-directory
        (expand-file-name (convert-standard-filename ,dir-name)
                          ,mel/auto-dir-n-file)))

    (defmacro mel/expand-auto-file (file-name)
      "Expand file name relative to `mel/auto-dir-n-file'"
      `(expand-file-name (convert-standard-filename ,file-name)
                         ,mel/auto-dir-n-file))
  #+end_src

  设置 default variable，使用 `setq' 只能让变量在某一个 buffer 中为设置的値，
  `setq-default' 可以修改这些变量的默认値。 ~fill-column~ 为一行最多可以保
  存的文字长度，使用 `A-q' 可以将一行很长的文字自动格式化成每一行只有
  ~fill-column~ 字符长度的一段文字。

  #+begin_src emacs-lisp :noweb-ref pref
    ;; set default fill-column 75
    (setq-default fill-column 75
                  ;; make indentation command use space only
                  indent-tabs-mode nil
                  ;; tab width
                  tab-width 2
                  ;; tab indent
                  tab-always-indent 'complete
                  ;; display line number
                  line-number-mode t
                  ;; display line number
                  column-number-mode t)
  #+end_src

  设置 emacs 界面，阻止 startup 界面，关闭 menu bar, tool bar，显示当前电池
  量。对于 =26.0.50= 版本，显示行号。

  #+begin_src emacs-lisp :noweb-ref pref
    ;; disable startup message
    (setq inhibit-startup-message t)

    ;; disable menu-bar
    (if (functionp 'menu-bar-mode) (menu-bar-mode -1))

    ;; disable tool-bar
    (if (functionp 'tool-bar-mode) (tool-bar-mode -1))

    ;; disable scrollbar
    (if (functionp 'scroll-bar-mode) (scroll-bar-mode -1))

    ;; battery
    (ignore-errors (display-battery-mode 1))

    ;; display line number
    (when (version<= "26.0.50" emacs-version)
      (global-display-line-numbers-mode))
  #+end_src

  设置 emacs 自带功能，使用 backup 功能，关闭 auto-save 功能。backup 功能在
  文件保存的时候会对保存之前的文件做一次备份。auto-save 功能隔一段时间就会
  用自动保存文件名格式自动保存一份这个文件，但是这个功能用了这么长时间
  emacs 也没用过，不如关了 auto-save 功能。

  #+begin_src emacs-lisp :noweb-ref pref
    ;; setup backup dir
    (let* ((emacs-backup-dir (mel/expand-auto-dir "backup")))
      (mel/mkdir emacs-backup-dir)
      (setq backup-directory-alist `((".*" . ,emacs-backup-dir))
            ;; don't delink hardlinks
            backup-by-copying t
            ;; use version numbers on backups
            version-control t
            ;; automatically delete excess backups
            delete-old-versions t
            ;; how many of the newest version to keep
            kept-new-versions 100
            ;; how many of the old
            kept-old-versions 3
            )) ;; end of backup dir setup

    ;; disable auto-save
    (setq auto-save-default nil)
  #+end_src

  update the contents of opened buffers when the associated file changes on
  disk.

  #+begin_src emacs-lisp :noweb-ref pref

    ;; revert buffer associated with a file when the file changes on disk
    (global-auto-revert-mode 1)
  #+end_src

  disable all mouse input.

  #+begin_src emacs-lisp :noweb-ref pref

    ;; disable mouse input
    (global-unset-key (kbd "<down-mouse-1>"))
    (global-unset-key (kbd "<mouse-1>"))
    (global-unset-key (kbd "<down-mouse-3>"))
    (global-unset-key (kbd "<mouse-3>"))
  #+end_src

  所有从 elpa 源下载的文件都放到 ~${HOME}/.emacs.d/pkgs~ 这个文件夹。将从网
  上直接下载的文件放到 ~${HOME}/.emacs.d/pkgs/non-elpa~ 这个文件夹。When
  the dir ~mel/non-elpa~ is created, we need to add it to ~load-path~ so as
  to let Emacs knows where to find the manually installed packages. More
  config option could be found on [[https://www.emacswiki.org/emacs/LoadPath][LoadPath]] of emacswiki.

  #+begin_src emacs-lisp :noweb-ref pref

    ;; create dir `pkgs' and `non-elpa'
    (defvar mel/pkgs
      (mel/expand-emacs-d "pkgs")
      "The directory to save elpa source files")

    (defvar mel/non-elpa
      (expand-file-name "non-elpa" mel/pkgs)
      "The directory to save manually download files")

    ;; create `pkgs' dir
    (mel/mkdir mel/pkgs)

    ;; create `non-elpa' dir
    (mel/mkdir mel/non-elpa)

    ;; add `non-elpa' and its subdirs to load-path
    (let ((default-directory mel/non-elpa))
      (normal-top-level-add-to-load-path '("."))
      (normal-top-level-add-subdirs-to-load-path))

    ;; func to expand pkgs dir
    (defmacro mel/expand-pkgs-dir (dir-name)
      "Expand dir name relative to `mel/pkgs'"
      `(file-name-as-directory
        (expand-file-name (convert-standard-filename ,dir-name)
                          ,mel/pkgs)))

    ;; func to expand pkgs file
    (defmacro mel/expand-pkgs-dir (file-name)
      "Expand file name relative to `mel/pkgs'"
      `(expand-file-name (convert-standard-filename ,file-name)
                         ,mel/pkgs))

    ;; func to expand non-elpa dir
    (defmacro mel/expand-non-elpa-dir (dir-name)
      "Expand dir name relative to `mel/non-elpa'"
      `(file-name-as-directory
        (expand-file-name (convert-standard-filename ,dir-name)
                          ,mel/non-elpa)))

    ;; func to expand non-elpa files
    (defmacro mel/expand-non-elpa-file (file-name)
      "Expand file name relative to `mel/non-elpa'"
      `(expand-file-name (convert-standard-filename ,file-name)
                         ,mel/non-elpa))
  #+end_src

  add a dir called 'el-file' to store private elisp scripts. And put this
  dir on top of ~load-path~, so libraries in this dir take precedence over
  others.

  #+begin_src emacs-lisp :noweb-ref pref-el
    ;; create dir `el-file'
    (defvar mel/el-file-dir
      (mel/expand-emacs-d "el-file")
      "Private elisp scripts directory")

    ;; create `el-file' dir
    (mel/mkdir mel/el-file-dir)

    ;; func to expand el-file files
    (defmacro mel/expand-el-file (file-name)
      "Expand file name relative to `mel/el-file'"
      `(expand-file-name (convert-standard-filename ,file-name)
                         ,mel/el-file-dir))

    ;; add `el-file' on top of load-path
    (let ((default-directory mel/el-file-dir))
      (setq load-path
            (append
             (let ((load-path (copy-sequence load-path))) ;; Shadow
               (append
                (copy-sequence (normal-top-level-add-to-load-path '(".")))
                (normal-top-level-add-subdirs-to-load-path)))
             load-path)))
  #+end_src
* [2021-06-27 Sun 22:32] 设置 org mode
  :PROPERTIES:
  :header-args: :tangle no
  :ID:       node-2021-06-27-22-32
  :END:

  org mode 在配置一开始就加载了，但是主要是为了使用 ~org-babel-load-file~
  这个函数将代码从 org 文件中 tangle up，这里对 org mode 进行正式的配置。

  #+begin_src emacs-lisp :noweb-ref cfg-org :noweb yes

    ;;
    ;; org-cfg
    ;;

    <<org-shortcut-config>>

    (use-package org
      ;; execute `org-config' when when we need to load org-mode
      :defer t
      :config
      <<org-config>>
      )
  #+end_src

  手动修改 invisible position in org file 时，将折叠区域打开并显示修改，这
  样做可以避免不小心将折叠区域修改了而不知情的情况发生（经常干这种蠢事）。

  #+begin_src emacs-lisp :noweb-ref org-config
    ;; show effect when requested to edit on invisible position
    (setq org-catch-invisible-edits 'show)
  #+end_src

  再来定义一些 TODO 关键字。一个条目应该从 UNREAD -> (TODO | WAIT) ->
  (DONE | CANCELED)，这里是不是应该画一个图，目前还不会画图 ... 先这样吧。
  UNREAD 状态到其他状态时记录下时间，从任何状态进入到 TODO、WAIT 或者
  CANCELED 状态时记录时间和说明，从任何状态进入到 DONE 状态时记录下时间。将
  这些 log 写到 drawer 里，平时并不是很想看到。

  参考 [[https://orgmode.org/manual/Tracking-TODO-state-changes.html#Tracking-TODO-state-changes][org manual]] 中对 tracking state changes 的说明，可以用 '/' 分隔进入状
  态和离开状态的操作。

  #+begin_src emacs-lisp :noweb-ref org-config
    ;; todo keywords
    (setq org-todo-keywords (quote ((sequence
                                     ;; todo item that need to clarify outcome or process immediately
                                     "UNREAD(u/!)"
                                     ;; making project plan which leads to the outcome
                                     "TODO(t@)"
                                     ;; interrupted by something, need to resume when the context is proper
                                     "WAIT(w@)"
                                     "|"
                                     "DONE(d!)"
                                     "CANCELED(c@)"))))
    ;; log drawer for state change
    (setq org-log-into-drawer t)

    ;; key binding to change todo state
    (define-key org-mode-map (kbd "C-c t") #'org-todo)
  #+end_src

  对于 DONE 状态的条目，将它们统一归档到 headline 为 '_ARCHIVE_' 的条目中。
  这种做法有个弊端：将多个 org 文件合并到一起时，会有多个 '_ARCHIVE_' 条目，
  看的比较操心。

  #+begin_src emacs-lisp :noweb-ref org-config
    ;; set org-archive-sibling-heading
    (setq org-archive-sibling-heading "_ARCHIVE_")
  #+end_src

  设置 global tags，'inbox' 记录突然想到，待处理的事情，'material' 为可以作
  为参考资料的内容，'note' 写一些平时的感悟，'project' 存储一些耗时比较长的
  工作，'canceled' 是被取消的工作，'ARCHIVE' 中主要包含一些一次性已经做完的
  事情。

  #+begin_src emacs-lisp :noweb-ref org-config
    ;; global tags list
    (setq org-tag-alist (quote (;; daily input
                                ("inbox" . ?i)
                                ;; reference material
                                ("material" . ?m)
                                ;; temporary idea
                                ("note" . ?n)
                                ;; stuff that needs more than five minutes to process
                                ("project" . ?p)
                                ;; keyword of current information node
                                ("kwd" . ?k)
                                ;; canceled todo item
                                ("canceled" . ?c)
                                ;; archived todo item
                                ("ARCHIVE" . ?a))))

    ;; key binding to set tags
    (define-key org-mode-map (kbd "C-c k") #'org-set-tags-command)
  #+end_src

  +org 可以根据 TODO state 的改变，自动修改 tags。+

  #+begin_src emacs-lisp :noweb-ref org-config-tags-triggers
    ;; todo state triggered tag change
    (setq org-todo-state-tags-triggers
          `(;; no todo keywords
            ("" ("inbox") ("project") ("canceled") ("ARCHIVE") ("note" . t))
            ;; add inbox tag to unread items
            ("UNREAD" ("inbox" . t))
            ;; add project tag to todo items, rm inbox tag
            ("TODO" ("inbox") ("project" . t))
            ;; add canceled tag to canceled items, rm inbox tag
            ("CANCELED" ("inbox") ("canceled" . t) ("ARCHIVE" . t))
            ;; add archive tag to done items, rm inbox and canceled
            ("DONE" ("inbox") ("canceled"))))
  #+end_src

  将 org-agenda-files 设置为 =user-emacs-directory= 下的一个目录，主要是想
  把所有的 org file 放到一起，方便离线操作。使用 org-refile 时，只对
  org-agenda-files 及当前正在编辑的 org 文件进行搜索，最大的查找深度设为 6
  。显示 org-refile 目标文件名，并将不同层级的 headline 以路径的形式显示。
  使用 ido 进行查找，不需要一级一级的查询。允许 org-refile 时创建新的根层级
  的 headline。

  多个设备如果都使用相同的 org file 结构，合并起来会有冲突，并且每次上传都
  要解决这些冲突问题。目前想到的一个方法是，给 org-directory 增加深度，不同
  的 device 放到不同的目录下，使用 `org-capture' 写入的时候，指定 device，
  放到对应目录下。([[id:node-2022-05-31-11-02-00-000000]])

  #+begin_src emacs-lisp :noweb-ref org-config-old

    (defvar mel/org-file-dir
      (mel/expand-emacs-d "org-file")
      "The directory to save org-files")

    (unless (bound-and-true-p mel/org-inbox-dev)
      (defvar mel/org-inbox-dev nil
        "relative path to `org-direcotry' for saving captured idea"))

    ;; create `mel/org-file-dir' in case it does not exist
    (mel/mkdir mel/org-file-dir)

    ;; create `mel/org-inbox-dev' in case it does not exist
    (if mel/org-inbox-dev
        (mel/mkdir (expand-file-name mel/org-inbox-dev mel/org-file-dir)))

    (defun mel/expand-org-file (file-name)
      "expang file name relative to `mel/org-file-dir'"
      (if mel/org-inbox-dev
          (expand-file-name
           (convert-standard-filename file-name)
           (file-name-as-directory
            (expand-file-name mel/org-inbox-dev mel/org-file-dir)))
        (expand-file-name
         (convert-standard-filename file-name) mel/org-file-dir)))

    (defvar mel/org-agenda-files
      (delete-dups
       (list
        ;; org-file-dir
        mel/org-file-dir
        ;; inbox dir. Utilize the expand function to get the inbox dir name. If
        ;; the mel/org-inbox-dev is not defined, this entry will be the same as
        ;; previous one.
        (file-name-as-directory (mel/expand-org-file "."))))
      "org-agenda files contains org-file-dir and inbox dir")

    ;; set org-agenda-files
    (setq org-agenda-files mel/org-agenda-files
          ;; set org-refile-targets
          org-refile-targets (quote (;; use current buffer
                                     (nil :maxlevel . 6)
                                     ;; use org-agenda-files for targets
                                     (org-agenda-files :maxlevel . 6)))
          ;; provide refile target as path
          org-refile-use-outline-path (quote file)
          ;; complete the outline path in a single go
          org-outline-path-complete-in-steps nil
          ;; create new parents
          org-refile-allow-creating-parent-nodes (quote confirm))
  #+end_src

  #+begin_src emacs-lisp :noweb-ref org-config

    (unless (bound-and-true-p mel/org-file-dir)
      (defvar mel/org-file-dir
        (mel/expand-emacs-d "org-file")
        "The directory to save org-files"))

    (unless (bound-and-true-p mel/org-inbox-dir)
      (defvar mel/org-inbox-dir
        (mel/expand-emacs-d "org-file")
        "The directory to save captured ideas"))

    ;; create `mel/org-file-dir' in case it does not exist
    (mel/mkdir mel/org-file-dir)

    (defmacro mel/expand-org-file (file-name)
      "expang file name relative to `mel/org-file-dir'"
      `(expand-file-name
        (convert-standard-filename ,file-name) ,mel/org-file-dir))

    (defmacro mel/expand-org-inbox-file (file-name)
      "expang file name relative to `mel/org-file-dir'"
      `(expand-file-name
        (convert-standard-filename ,file-name) ,mel/org-inbox-dir))

    ;; set org-agenda-files
    (setq org-agenda-files (list mel/org-file-dir)
          ;; set org-refile-targets
          org-refile-targets (quote (;; use current buffer
                                     (nil :maxlevel . 6)
                                     ;; use org-agenda-files for targets
                                     (org-agenda-files :maxlevel . 6)))
          ;; provide refile target as path
          org-refile-use-outline-path (quote file)
          ;; complete the outline path in a single go
          org-outline-path-complete-in-steps nil
          ;; create new parents
          org-refile-allow-creating-parent-nodes (quote confirm))
  #+end_src

  私以为 org mode 里最好用的应该是 org-capture ，可以方便的记下笔记。先设置
  org-capture 使用的文件目录 `org-directory' 和`org-default-notes-file'，
  `org-directory' 不只在 org-capture 里用到，因为我将 org 文件都放到了一个
  文件夹里去了，也就可以不用管它们的区别了。

  #+begin_src emacs-lisp :noweb-ref org-config

    ;; set `org-directory' and `org-default-notes-file'
    (setq org-directory mel/org-file-dir
          org-default-notes-file (mel/expand-org-file "note.org"))
  #+end_src

  先定义一个添加 template 的函数，方便以后添加 template。

  #+begin_src emacs-lisp :noweb-ref org-config

    ;; clear org-capture-template
    (setq org-capture-templates nil)
    ;; org-capture configuration func
    (defun mel/org-cap-add-temp (key desc type target temp)
      (push `(,key ,desc ,type ,target ,temp) org-capture-templates))
  #+end_src

  - =inbox.org= 文件用来记录待办事项。

    配置默认的 =mel/org-inbox-file=
    #+begin_src emacs-lisp :noweb-ref org-config-old

      ;; capture inbox
      (defcustom mel/org-inbox-file
        (mel/expand-org-file "inbox.org")
        "org mode knowledge management system(KMS) inbox file. Using
        `mel/org-work-on' to customize it")
    #+end_src

    + [2022-08-29 Mon 16:56] [[id:node-2021-06-27-22-32][使用 =mel/org-work-on= 函数]]，不在这里配置
      template, 将 noweb-ref 由 org-config 改为 org-config-old
      #+begin_src emacs-lisp :noweb-ref org-config-old
        ;; capture inbox
        (let ((mel/org-inbox-file (mel/expand-org-file "inbox.org")))
          (mel/org-cap-add-temp "i" "Inbox" 'entry `(file ,mel/org-inbox-file) "* UNREAD %T %?"))
      #+end_src

  - =note.org= 文件用来记录平时的随想。

    =mel/org-note-file= 的默认値已经在上面跟 org-directory 一起定义过了。

    + [2022-08-29 Mon 16:56] 使用 =mel/org-work-on= 函数
      #+begin_src emacs-lisp :noweb-ref org-config-old
        ;; capture note
        (mel/org-cap-add-temp "n" "Note" 'entry `(file ,mel/org-note-file) "* %T %?")
      #+end_src

  - =material.org= 文件用来记录平时遇到问题的解决方法，作用类似于一个工具书。

    配置默认的 =mel/org-material-file=
    #+begin_src emacs-lisp :noweb-ref org-config-old
      ;; capture material
      (defcustom mel/org-material-file
        (mel/expand-org-file "material.org")
        "org mode KMS material file. Using `mel/org-work-on' to
        customize it")
    #+end_src

    + [2022-08-29 Mon 16:56] 使用 =mel/org-work-on= 函数
      #+begin_src emacs-lisp :noweb-ref org-config-old
        ;; capture material
        (let ((mel/org-material-file (mel/expand-org-file "material.org")))
              (mel/org-cap-add-temp "m" "Material" 'entry `(file ,mel/org-material-file) "* %T %?"))
      #+end_src

  - =journal.org= 类似于日记。

    配置默认的 =mel/org-journal-file=
    #+begin_src emacs-lisp :noweb-ref org-config-old
      ;; capture journal
      (defcustom mel/org-journal-file
        (mel/expand-org-file "journal.org")
        "org mode KMS journal file. Using `mel/org-work-on' to customize
        it")
    #+end_src

    + [2022-08-29 Mon 16:56] 使用 =mel/org-work-on= 函数
      #+begin_src emacs-lisp :noweb-ref org-config-old
        ;; capture journal
        (let ((mel/org-journal-file (mel/expand-org-file "journal.org")))
          (mel/org-cap-add-temp "j" "Journal" 'entry `(file+olp+datetree ,mel/org-journal-file) "* %U %?"))
      #+end_src

  - =project.org= 更正式一点，因为是个长期工作，需要考虑它是什么，使用
    project 这个 template 时，headline 由提示输入，tag 名也由提示输入；tag
    提示一共有两个，对于 project header ，其中一个 tag 应该是 prj，另一 个
    tag是这个 project 的 tag name。这样，在 agenda 中使用 prj 这个 tag 去搜
    索时，会显示所有的 project header，使用 project 的 tag name 去搜索时，
    会显示所有与这个 project 相关的 entries。如果 capture 要记录的是某个
    project 相关的 entry，而不是 project header，可以将其中一个 tag 留空
    （在提示输入 tag时，直接回车），另一个 tag 提示的时候使用 tab 键查找对
    应 project 的 tag name。

    配置默认的 =mel/org-prj-file=
    #+begin_src emacs-lisp :noweb-ref org-config-old
      ;; capture project
      (defcustom mel/org-prj-file
        (mel/expand-org-file "project.org")
        "org mode KMS project file. Using `mel/org-work-on' to
        customize it")
    #+end_src

    + [2022-08-29 Mon 16:56] 使用 =mel/org-work-on= 函数
    #+begin_src emacs-lisp :noweb-ref org-config-old
      ;; capture project
      (let ((mel/org-prj-file (mel/expand-org-file "project.org")))
        (mel/org-cap-add-temp "p" "Project" 'entry `(file ,mel/org-prj-file) "* %U %^{headline} %^G%^G\n\n%?"))
    #+end_src

  - 日常工作中每天还要写周报，加个 =review.org= ，记录每周周报。日常工作中
    用的 emacs 环境需要将 :tangle no 和 :noeval 这两个 header args 删除。

    配置默认的 =mel/org-review-file=
    #+begin_src emacs-lisp :noweb-ref org-config-old
      ;; capture weekly review
      (defcustom mel/org-review-file
        (mel/expand-org-file "review.org")
        "org mode KMS review file. Using `mel/org-work-on' to customize
        it")
    #+end_src

    + [2022-08-29 Mon 16:56] 使用 =mel/org-work-on= 函数
    #+begin_src emacs-lisp :noweb-ref org-config-old
      ;; capture weekly review
      (let ((mel/org-review-file (mel/expand-org-file "review.org")))
        (mel/org-cap-add-temp "r" "Review" 'entry `(file ,mel/org-review-file) "* %T %(format-time-string \"%W\")-th review\n%?"))
    #+end_src

  最后，添加 org-agenda 和 org-capture 的快捷鍵，设置 "C-c c" 调用
  org-capture ，"C-c a" 调用 org-agenda。

  #+begin_src emacs-lisp :noweb-ref org-shortcut-config
    ;; set shortcut to org-capture, org-agenda
    (global-set-key (kbd "C-c c") #'org-capture)
    (global-set-key (kbd "C-c a") #'org-agenda)
  #+end_src

** <2022-07-10 Sun 10:12> org mode 中添加 work-on 功能
   :PROPERTIES:
   :ID:       node-2022-07-10-10-12-00-000000
   :ts:       <2022-07-10 Sun 10:12>
   :END:
   现实中遇到的情况是，笔记本与台式机都使用相同的 org-file 文件夹结构，导致
   两个 inbox org 文件相互冲突，每次整理 org-file 很麻烦，一会切换到笔记本的
   inbox，一会切换到台式机的 inbox 上。添加 =mel/org-work-on= 函数的主要想法
   是，输入一行命令，保持其他文件位置不变，切换 inbox 文件。
   #+begin_src emacs-lisp :noweb-ref org-config-old

     ;; handy function to specify files to work on
     (defun mel/org-work-on (;; inbox specific files
                             inbox-file journal-file review-file
                             &optional
                             ;; general files
                             prj-file note-file material-file)
       "specify org files(in relative path) to work on"
       (let ((mel/org-inbox
              (or inbox-file mel/org-inbox-file))
             (mel/org-journal
              (or journal-file mel/org-journal-file))
             (mel/org-review
              (or review-file mel/org-review-file))
             (mel/org-prj
              (or prj-file mel/org-prj-file))
             (mel/org-note
              (or note-file mel/org-note-file))
             (mel/org-material
              (or material-file mel/org-material-file)))
         (run-hooks 'mel/org-before-set-temp-hook)
         ;; clear templates
         (setq org-capture-templates nil)
         ;; capture inbox
         (mel/org-cap-add-temp "i" "Inbox"
                               'entry
                               `(file ,mel/org-inbox)
                               "* UNREAD %T %?")
         (push (file-name-directory mel/org-inbox) mel/org-agenda-files)
         ;; update
         (setq mel/org-inbox-file mel/org-inbox)
         ;; capture note
         (mel/org-cap-add-temp "n" "Note"
                               'entry
                               `(file ,mel/org-note)
                               "* %T %?")
         (push (file-name-directory mel/org-note) mel/org-agenda-files)
         ;; update
         (setq mel/org-note-file mel/org-note)
         ;; capture material
         (mel/org-cap-add-temp "m" "Material"
                               'entry
                               `(file ,mel/org-material)
                               "* %T %?")
         (push (file-name-directory mel/org-material) mel/org-agenda-files)
         ;; update
         (setq mel/org-material-file mel/org-material)
         ;; capture journal
         (mel/org-cap-add-temp "j" "Journal"
                               'entry
                               `(file+olp+datetree ,mel/org-journal)
                               "* %U %?")
         (push (file-name-directory mel/org-journal) mel/org-agenda-files)
         ;; update
         (setq mel/org-journal-file mel/org-journal)
         ;; capture project
         (mel/org-cap-add-temp "p" "Project"
                               'entry
                               `(file ,mel/org-prj)
                               "* %U %^{headline} %^G%^G\n\n%?")
         (push (file-name-directory mel/org-prj) mel/org-agenda-files)
         ;; update
         (setq mel/org-prj-file mel/org-prj)
         ;; capture weekly review
         (mel/org-cap-add-temp "r" "Review"
                               'entry
                               `(file ,mel/org-review)
                               "* %T %(format-time-string \"%W\")-th review\n%?")
         (push (file-name-directory mel/org-review) mel/org-agenda-files)
         ;; update
         (setq mel/org-review-file mel/org-review)
         ;; delete duplicated agenda dir
         (delete-dups mel/org-agenda-files)))
   #+end_src
   使用示例：
   #+begin_src emacs-lisp :noweb-ref org-config-old

     ;; using default work-on file
     (mel/org-work-on
      ;; inbox-file (mel/expand-org-file "inbox/work/inbox.org")
      nil
      ;; journal-file (mel/expand-org-file "inbox/work/journal.org")
      nil
      ;; review-file  (mel/expand-org-file "inbox/work/review.org")
      nil
      )
   #+end_src
** [2022-09-07 Wed 15:48] mel/org-work-on 这个功能是不是只需要两个目录就够了？
   一个目录用来作 org-directory，一个目录用来作 inbox，用户在运行
   mel/org-work-on 的时候只要选择使用哪个目录就可以了。

   可以参考 pyvenv.el:272 的 `pyvenv-workon' 函数，使用 `interactive'。

   #+begin_src emacs-lisp :noweb-ref org-config

     (defun mel/org-capture-workon (base-dir inbox-dir note-file)
       "specify directories for org-capture to work on."
       (interactive
        (let ((b-dir (read-directory-name "org base dir: " mel/org-file-dir mel/org-file-dir))
              (i-dir (read-directory-name "captured inbox dir: " mel/org-inbox-dir mel/org-inbox-dir))
              (n-file (read-file-name "note file: " mel/org-file-dir org-default-notes-file)))
          (when (or
                 (not (file-directory-p b-dir))
                 (member b-dir (list "" nil)))
            (message "org base dir NOT existed. Using %s" mel/org-file-dir)
            (setq b-dir mel/org-file-dir))
          (when (or
                 (not (file-directory-p i-dir))
                 (member i-dir (list "" nil)))
            (message "captured inbox dir NOT existed. Using %s" mel/org-inbox-dir)
            (setq i-dir mel/org-inbox-dir))
          (when (or
                 (not (file-exists-p org-default-notes-file))
                 (member n-file (list "" nil)))
            (message "note file NOT existed. Using %s" org-default-notes-file)
            (setq n-file org-default-notes-file))
          (list b-dir i-dir n-file)))
       (setq mel/org-file-dir base-dir
             mel/org-inbox-dir inbox-dir
             org-directory base-dir
             org-default-notes-file note-file
             org-agenda-files (list base-dir inbox-dir))
       ;; clear templates
       (setq org-capture-template nil)
       ;; capture inbox
       (mel/org-cap-add-temp "i" "Inbox"
                             'entry
                             `(file ,(mel/expand-org-inbox-file "inbox.org"))
                             "* UNREAD %T %?")
       ;; capture note
       (mel/org-cap-add-temp "n" "Note"
                             'entry
                             `(file ,org-default-notes-file)
                             "* %T %?")
       ;; capture material
       (mel/org-cap-add-temp "m" "Material"
                             'entry
                             `(file ,(mel/expand-org-file "material.org"))
                             "* %T %?")
       ;; capture journal
       (mel/org-cap-add-temp "j" "Journal"
                             'entry
                             `(file+olp+datetree ,(mel/expand-org-inbox-file "journal.org"))
                             "* %U %?")
       ;; capture project
       (mel/org-cap-add-temp "p" "Project"
                             'entry
                             `(file ,(mel/expand-org-inbox-file "project.org"))
                             "* %U %^{headline} %^G%^G\n\n%?")
       ;; capture weekly review
       (mel/org-cap-add-temp "r" "Review"
                             'entry
                             `(file ,(mel/expand-org-inbox-file "review.org"))
                             "* %T %(format-time-string \"%W\")-th review\n%?"))
   #+end_src

   使用示例：
   #+begin_src emacs-lisp :noweb-ref org-config

     ;; using default work-on file. if org-mode configuration is loaded after
     ;; the initialization of emacs, these variable could be configured during
     ;; the initial process.
     (mel/org-capture-workon
      ;; base dir for all org files.
      mel/org-file-dir
      ;; inbox dir for captured ideas
      mel/org-inbox-dir
      ;; default org-capture note file
      org-default-notes-file)
   #+end_src

   因为 `mel/org-capture-workon' 只是一个函数，我们需要调用一下才能完成对
   `org-capture-templates' 的配置。因为 org-mode 的配置信息是只有加载了
   `org.el' 之后才调用的，如果想让默认的 inbox-dir 为自定义的文件夹，需要在
   on-going.el 文件中先配置 `mel/org-file-dir', `mel/org-inbox-dir' 和
   `org-default-notes-file'.
** [2022-09-07 Wed 15:30] 在设置 org-capture 之前加一个 hook
   这样就可以在 org mode 加载之后再去运行已经加载的配置文件中的信息。

   #+begin_src emacs-lisp :noweb-ref org-config-old

     (defvar mel/org-before-set-temp-hook nil
       "Hooks run before setting org-capture template")
   #+end_src

   使用方法：
   #+begin_src emacs-lisp
     (defun your-func()
       "Customize mel/org-inbox-file, mel/org-journal-file,
       mel/org-review-file, mel/org-prj-file, mel/org-note-file, mel/org-material-file"
       (setq mel/org-inbox-file "path/to/inbox/file"
             mel/org-journal-file "path/to/journal/file"
             mel/org-review-file "path/to/review/file"
             mel/org-prj-file "path/to/prj/file"
             mel/org-note-file "path/to/note/file"
             mel/org-material-file "path/to/material/file"
             ))

     (add-hook 'mel/org-before-set-temp-hook 'your-func)
   #+end_src
*** ref
    - [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Hooks.html][emacs hooks]]
** [2021-06-08 Tue 16:48] inhibit tag inheritance in ~tags~ and type agenda generation

  使用 org-agenda 生成 tags 类型的 agenda 时，如果某个 subtree 下面有很多子
  subtree，最高层 subtree 的 tags 会继承给所有子 subtree，生成的 agenda 冗
  长，找不到关键信息。

  搜 org mode 关于 tags inheritance，找到了关闭继承的方法：将
  `org-agenda-use-tag-inheritance' 设置成 nil。

  #+begin_src emacs-lisp :noweb-ref org-config

    ;; disable tag inheritance to make a concise tag searching result in agenda
    ;; view
    (setq org-agenda-use-tag-inheritance nil)
  #+end_src

** [2021-07-27 Tue 22:51] info node id

#+begin_src emacs-lisp :noweb-ref org-config

  ;; activate org-id
  (add-to-list 'org-modules 'org-id t)
  (defun mel/org-set-node-id (&optional goto pom)
    "Set the ID property of the entry at point-or-marker POM.
  If POM is nil, refer to the entry at point. The function create a
  ID if none is present already. The ID of the entry is returned.

  With a `\\[universal-argument]' prefix argument, delete timestamp
  in the headline."
    (interactive "P")
    (org-with-point-at pom
      ;; make sure we are not before the first heading
      (unless (org-before-first-heading-p)
        (let* ((id (org-entry-get nil "ID"))
               (ts (org-entry-get nil "ts"))
               (ts-a (org-entry-get nil "TIMESTAMP"))
               (ts-ia (org-entry-get nil "TIMESTAMP_IA"))
               ;; set id format
               (id-format "node-%Y-%m-%d-%H-%M")
               ;; high time resolution id format, with the precision of microsecond
               (id-fmt-h "node-%Y-%m-%d-%H-%M-%S-%6N")
               ;; set default internal-time to current time if ts-a and ts-ia is no available
               (internal-time (time-convert (current-time) 'list))
               (id-str nil)
               (heading (nth 4 (org-heading-components)))
               (head-str (string-trim
                          ;; replace front-most timestamp with empty in headline
                          (replace-regexp-in-string
                           (concat "^" org-ts-regexp-both) "" heading))))
          ;; prompt if there is no `ID', active timestamp or inactive timestamp
          (unless (or ts-a ts-ia id)
            (message "Current time will be used. Node without an Active/Inactive timestamp"))
          ;; set time
          (if (or ts ts-a ts-ia)
              (setq internal-time (org-time-string-to-time (or ts ts-a ts-ia))))
          ;; fill id-str
          (setq id-str (format-time-string id-format internal-time))
          (setq id-str-h (format-time-string id-fmt-h internal-time))
          ;; set id if not eq. assuming all `ID' have high time resolution,
          ;; only low time resolution parts of the `ID's need to be compared.
          (unless (and id (compare-strings id nil (length id-str) id-str nil nil))
            (org-entry-put pom "ID" id-str-h)
            ;; set id and id-str to id-str-h
            (setq id id-str-h id-str id-str-h)
            (org-entry-put pom "ts" (format-time-string (cdr org-time-stamp-formats) internal-time))
            (org-id-add-location id-str-h (buffer-file-name (buffer-base-buffer))))
          (unless (not (equal goto '(4)))
            ;; move timestamp to ts property
            (if (or ts-a ts-ia)
                (org-entry-put pom "ts" (or ts-a ts-ia)))
            ;; delete timestamp in headline if the heading is not an empty string
            (unless (string-empty-p head-str)
              (org-edit-headline head-str)))
          ;; return plist
          (list :link (concat "id:" id) :description head-str)))))

  ;; bind keys
  (define-key org-mode-map (kbd "C-c i") 'mel/org-set-node-id)
#+end_src

** [2021-11-18 Thu 18:08] context info for sparse tree view

设置使用 org sparse tree 查找时显示的内容丰富度
#+begin_src emacs-lisp :noweb-ref org-config
  ;; set revealing context
  (setq org-show-context-detail (append org-show-context-detail '((tags-tree . local))))
#+end_src

** [2021-11-23 Tue 12:40] map-pos

添加一个函数，用来添加标号信息 map-pos ，接收用戶输入，将输入信息作为
map-pos，写到 property 中，写 mind-map 时，使用 column view，将 map-pos 作
为一个 field 显示出来，那样 org 文档就不会显得特别凌乱，还不会影响 org 文档
每个节点之间的格式。

#+begin_src elisp :noweb-ref org-config
  (defun mel/org-set-map-pos (map-pos &optional pom)
    "Set the mind-map position of the entry at point-or-marker POM.
  If the POM is nil, refer to the entry at point."
    (interactive "smap pos: ")
    (org-with-point-at pom
      (let ((old-pos (org-entry-get nil "MAP_POS")))
        (if (and old-pos (stringp old-pos))
            (message "map pos: %s --> %s" old-pos map-pos))
        (if (not (string-empty-p (string-trim map-pos)))
            (org-entry-put pom "MAP_POS" map-pos)
          (org-entry-delete pom "MAP_POS"))
        map-pos)))

  ;; bind keys
  (define-key org-mode-map (kbd "C-c m") 'mel/org-set-map-pos)
#+end_src
** [2022-01-15 Sat 22:33] org config 中添加一个 copy id 的函数

  用 org-entry-get 获取 id ，然后使用 org-kill-new 函数将 id 保存到
  kill-ring 中，方便在需要的位置使用 yank 将 kill-ring 中的 id 粘贴到

#+begin_src emacs-lisp :noweb-ref org-config

  ;; copy id to kill ring
  (defun mel/org-copy-id (&optional goto pom)
    "copy id of the entry at POM. if POM is undefined, copy id of
  the entry at pointer.

  With a `\\[universal-argument]' prefix argument, delete timestamp
  in the headline."
    (interactive "P")
    (org-with-point-at pom
      (let ((str-id (org-entry-get nil "ID" t))
            ;; marker pointing to the entry where the `ID' is inherited. The
            ;; marker `org-entry-property-inherited-from' is set each time
            ;; ‘org-entry-get-with-inheritance’ is called.
            (id-from-marker org-entry-property-inherited-from)
            (heading-inherited nil)
            ;; current headline
            (str-headline (nth 4 (org-heading-components)))
            (str-ref nil)
            (str-desc nil))
        ;; if `str-id' is empty, set node id, then copy it to `str-id'
        (unless (and str-id (not (string-blank-p str-id)))
          ;; set node id
          (mel/org-set-node-id goto pom)
          (setq str-id (org-entry-get nil "ID" t)))
        ;; get heading of the entry where `ID' is inherited
        (when id-from-marker
          (org-with-wide-buffer
           (goto-char id-from-marker)
           (setq heading-inherited (nth 4 (org-heading-components)))))
        (if (and heading-inherited (not (string= heading-inherited str-headline)))
            (setq str-desc (format "%s::%s" heading-inherited str-headline))
          (setq str-desc str-headline))
        ;; construct reference with id
        (setq str-ref (format "[[id:%s][%s]]" str-id str-desc))
        (org-kill-new str-ref)
        ;; return link str-id and str-headline
        (list :link (concat "id:" str-id) :description str-desc))))
  ;; bind keys
  (define-key org-mode-map (kbd "C-c y") 'mel/org-copy-id)
#+end_src
** [2022-01-17 Mon 09:58] org mode hide block

org mode 通过 '#+begin' ... '#+end' 控制符声明控制符内文字的特殊用途，浏览
的时候可以将控制符内的文字折叠起来，literal programming 就用的这类控制符。
打开 org 文件的时候，如果把所有控制符中的文字都打开，会感觉很蹧心啊。

参考 org mode 对 [[https://www.gnu.org/software/emacs/manual/html_node/org/Blocks.htmlhttps://www.gnu.org/software/emacs/manual/html_node/org/Blocks.html][blocks]] 的使用说明，可以通过配置 `org-hide-block-startup'
变量或者在 org 文件开头添加 property:

#+begin_example
#+STARTUP: hideblocks
#+end_example

per file property 用起来好像有点问题，配置一个 key-binding 吧。

#+begin_src emacs-lisp :noweb-ref org-config
  ;; toggle block visibility
  (defun mel/org-toggle-blocks ()
    (interactive)
    (org-hide-block-toggle-all))

  (define-key org-mode-map (kbd "C-c h") 'mel/org-toggle-blocks)
#+end_src
** [2022-05-20 Fri 14:30] org config 中添加 back ref 功能
   每次看 node 的时候总感觉想起来点什么，但是又记不起来，后面隔了很久之后看
   到了链接位置，又忘了之前想找链接的缘由，给每个 node 加个 back reference
   功能，每次插链接的时候随手添加一下 back reference，解决感觉想起来却找不
   到记不起来的问题。

   back ref 的功能逻辑：

   - copy 当前 entry 的 id (mel/org-copy-id)
   - 跳转到 ref 的 entry (org-link-open)
     + 找到 entry 的 ref heading (org-map-entries, org-heading-componets, org-get-heading)
       * 如果没有 heading 是 ref 的 subtree 就新建一个 (org-insert-heading)
       * 查找所有 items，看有没有 id 相同的 item
         - 如果有，当前 id link 添加处理结束
         - 如果没有，在 ref 下新建一个 item，指向 copy 的 entry id (org-in-item-p, org-list-insert-item, org-end-of-item-list)
     + 跳转回原先的 entry (org-mark-ring-goto)
#+begin_src emacs-lisp :noweb-ref org-config

  (defun mel/org-back-ref-node (&optional goto pom)
    "Setup backward reference for `id' type org link.

  `id' of current subtree is used as the link in the referenced
  subtree.

  With a `\\[universal-argument]' prefix argument, use inherited ID
  info if possible."
    (interactive "P")
    (let* ((from-link
            (if (equal goto '(4))
                (mel/org-copy-id)
              (mel/org-set-node-id)))
           ;; construct from-link-str
           (from-link-str (format "[[%s][%s]]"
                                  (plist-get from-link :link)
                                  (plist-get from-link :description)))
           (to-context (org-element-context))
           (to-id
            (pcase (org-element-property :type to-context)
              ("id" (org-element-property :path to-context))
              (_ nil)))
           (ref-heading "ref")
           (found-p nil)
           (to-has-subheading nil)
           (to-level nil)
           (to-heading ""))
      (if (not to-id)
          (user-error "Not an \"id\" TYPE link"))
      ;; goto beginning of linked headline
      (org-id-open to-id 'dont-care)
      (setq to-level (nth 0 (org-heading-components)))
      ;;(setq to-heading (nth 4 (org-heading-components)))
      (save-restriction
        (org-narrow-to-subtree)
        ;; goto `ref' headline
        (while (and (< (point) (point-max)) (not found-p))
          (org-next-visible-heading 1)
          (setq to-heading (nth 4 (org-heading-components)))
          (if (string= ref-heading (string-trim to-heading))
              (setq found-p t)))
        ;; ref entry cannot been found
        (when (not found-p)
          ;; check to see if we are at a sub-heading
          (setq to-has-subheading (> (nth 0 (org-heading-components)) to-level))
          ;; insert heading below current entry
          (org-insert-heading-respect-content)
          ;; unless the target entry has sub-heading, we demote ref as
          ;; subtree of current heading
          (unless to-has-subheading
            (org-demote-subtree))
          ;; insert ref headling
          (org-edit-headline ref-heading)
          ;; insert link
          (insert "\n" "- " from-link-str))
        ;; insert link in the ref entry
        (when found-p
          ;; goto beginning of item
          (condition-case err
              (org-list-search-forward (org-item-beginning-re))
            (error
             (message "no list item in `ref' heading, item will be inserted at the end of the entry")
             ;; no list item in ref, insert one.
             ;; we are at the beginning of the ref heading
             (end-of-line)
             (insert "\n" "- " from-link-str)
             ;; use found-p as the list-existing indicator
             (setq found-p nil)))
          ;; search for existing id type link
          (when found-p
            (condition-case err
                (org-list-search-forward (plist-get from-link :link))
              ;; there is no duplicated link. Insert the link to the list
              (error
               (org-insert-item)
               (insert from-link-str)
               ;; sorting the ref list
               (org-sort-list nil ?a))))))
      ;; go back to the link position
      (org-mark-ring-goto 1)))

  ;; bind keys
  (define-key org-mode-map (kbd "C-c b") 'mel/org-back-ref-node)
#+end_src

** [2023-01-02 Mon 20:04] org capture 时不要向 bookmark-default 文件中添加 bookmark point
org-capture-bookmark 设置为 nil

#+begin_src emacs-lisp :noweb-ref org-config
  ;; do not add bookmark pointing at the last stored position when capturing.
  (setq org-capture-bookmark nil)
#+end_src

好像这个变量设置了也没有多大用，还是使导致 bookmark-default.el 文件的更新。

* [2021-07-04 Sun 19:26] 设置 color theme
  :PROPERTIES:
  :header-args: :tangle no
  :END:

  已经 [[id:node-2022-04-15-09-57-00-000000][<2022-04-15 Fri 09:57> 把 cfg-theme 部分移出去]]了，感觉这部分的加载不
  应该在这个位置。

  目前来看 zenburn theme 感觉还行，比较习惯于看这个 theme 配置的颜色。

  #+begin_src emacs-lisp :noweb-ref cfg-theme
    ;; install zenburn-theme
    (mel/require-package 'zenburn-theme)

    ;; load zenburn theme
    (load-theme 'zenburn t nil)
  #+end_src
* [2021-07-04 Sun 19:56] setup emacs font

  参考 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/][elisp manual]]。emacs 要将一个字显示出来，会涉及到 face, font, fontset
  这三个概念。emacs 如果要显示 unicode 中的一个 character（unicode及 utf-8
  可以参考[[http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html][这个链接]]），就需要为这个 character 找到对应的符号，并将这个符号显
  示到屏幕上去。face 指的是 emacs 显示这个符号时与这个符号相关的属性。font
  指的是某种有文字语言下部分或者全部的符号。fontset 是多个 font的合集。
* [2021-07-09 Fri 14:29] add on-going setting
   :PROPERTIES:
   :header-args: :tangle no
   :ID:       node-2021-07-09-14-29-00-000000
   :ts:       <2021-07-09 Fri 14:29>
   :END:

keep some on-going setting in =on-going.el= file. Load the on-going
configuration if it exists in =el-file= dir after emacs initialiation
process.

#+begin_src emacs-lisp :noweb-ref init-load-ongoing :noeval
  ;; load on-going settings
  (let ((on-going-file
         (expand-file-name "el-file/on-going.el" user-emacs-directory)))
    (if (file-exists-p on-going-file)
        (load-file on-going-file)
      (message "config file %s NOT FOUND" on-going-file)))
#+end_src
* [2021-07-16 Fri 19:32] collect auto file
   :PROPERTIES:
   :header-args: :tangle no
   :END:

  The `auto file' means configuration files generated by the built-in
  packages in GNU Emacs.

  Most of the functions are copied from [[https://github.com/emacscollective/no-littering][no-littering]] pacakge. But I
  discarded third-party package configuration files.

  The script are stored in `mel/non-elpa' dir.

  #+begin_src emacs-lisp :noweb-ref cfg-no-litter

    ;; require customized no-littering
    (require 'mel-no-littering)
  #+end_src
* [2021-07-21 Wed 17:10] 添加 "C-." 作为 read-only-mode 的快捷键
   :PROPERTIES:
   :header-args: :tangle no
   :END:

因为对 emacs 的按键还不是特别熟练，总是会碰到输入或者按了不知道什么键，最后
把整个 work flow 都打乱，导致干活的时候总是磕磕绊绊，特别不爽。想找到某种方
式去规避这个问题，查了 'god-mode', 'evil-mode'，这些工具与我的需求好像又并
不是十分匹配，最后想到一个办法：一段时间不输入之后，将 buffer 转换为
'read-only-mode' ，需要重新输入时，使用快捷键关闭 'read-only-mode'。
#+begin_src emacs-lisp :noweb-ref pref-ro-obsolete

  ;; bind Ctrl-. to toggle read-only-mode
  (global-set-key (kbd "C-.") #'read-only-mode)

  ;; set current visiting file to read-only-mode
  (defun mel-set-buf-ro ()
    (if (and (buffer-file-name) (not (bound-and-true-p read-only-mode)))
        (read-only-mode 1)))

  ;; run command when emacs is idle for 10 secs
  (run-with-idle-timer 10 t 'mel-set-buf-ro)
#+end_src
** ref
- [[id:node-2022-02-22-19-37-00-000000][将 'C-.' 改为 'C-x m' 作为 read-only-mode 的快捷键]]
* [2021-07-30 Fri 15:45] 使用 org crypt 加密某些 org file entries

昨天晚上乱试密码，把一个帐号给弄锁定了，好记性不如烂笔头！把这些个密码都记
下来，防止以后又干相同的蠢事。

因为 org-crypt 需要用到 GnuPG，先要在计算机上安装 GnuPG，windows 上可以 使
用 chocolatey 安装 gnupg，unix-like system 建议安装 gnupg2.

#+begin_src emacs-lisp :noweb-ref org-config

  ;; use org-crypt to encrypt/decrypt private info
  (use-package org-crypt
    :config
    (org-crypt-use-before-save-magic)
    (setq org-tags-exclude-from-inheritance (quote ("crypt")))
    :custom
    ;; GPG key to use for encryption
    ;; either the key id or set to nil to use symmetric encryption.
    (org-crypt-key nil))
#+end_src

使用 private key 的配置方式可以参考[[https://www.clintonboys.com/gpg/][这个 blog]]里的配置。

写需要加密的 text of entry 时，需要给这个 entry 加上 ':crypt:' tag。
另外，最好在有加密操作的 org 文件最开始位置加上下面这一段标识：
#+begin_example
  # -*- buffer-auto-save-file-name: nil -*-
#+end_example
标记这个文件不要开启 backup ，这样 emacs 就不可能在你看 password 的时候把这
个文件写到备份文件夹中。但是不好的一点是，每次打开带这种头的 org 文件都会有
一些提示信息：
#+begin_example
  The local variables list in file.org
  contains variables that are risky (**).

  Do you want to apply it?  You can type
  y  -- to apply the local variables list.
  n  -- to ignore the local variables list.

   ,** buffer-auto-save-file-name : nil
#+end_example

可以参考 [[https://orgmode.org/manual/Org-Crypt.html][org crypt]] 的官方文档及 [[https://orgmode.org/worg/org-tutorials/encrypting-files.html][org tutorial]] 的说明。

* [2021-08-04 Wed 10:54] 更新 org entry remainly time property

想找一个工具做 project road map 功能，但是网上搜了大半天，都没有一个满意的
结果。

从功能上看，我需要一个可以作 Gantt chart 的工具，画出每个任务的时间线，然后
一个一个解决。看着看着，发现想要的更多，除了排时间线，我还要记工作日志，每
周或者一段时间后，对这个任务进行总结，列出来 DOING 及 TODO 项，指出每个任务
之间的依赖关系，越想越多，好像 OmniPlan 可以完成这部分工作，但是平台不支持，
它只支持 Apple 的 Mac 及相关平台。

后面看到 org mode 中可以使用 column view 做类似的事情，[[https://orgmode.org/worg/org-tutorials/org-taskjuggler.html][creating gantt chart
by exporting to taskjuggler]] 以及 [[https://orgmode.org/worg/org-tutorials/org-column-view-tutorial.html][column view tutorial]] 打算使用 org 中的
column view 作 project road-map 功能，导出到 taskjuggler 这个功能太鸡肋了，
还不如直接看 column view。有一个问题是，column view 只是一个 overlay over a
buffer，没办法实现类似于 org table 的 column formula 计算功能，如果想看
remaining days before deadline 就需要给它添加一个 property 显示的表示当前还
有几天到 deadline。

~mel/org-subtree-get-days-before-ddl~ 这个函数就是用来更新一个 entry 下所有
subtree离它们对应 deadline 的时间，如果某个 subtree 没有 deadline，则什么也
不做

#+begin_src emacs-lisp :noweb-ref org-config

  (defun mel/org-get-days-before-ddl (&optional pom)
    "set the BEFORE_DDL property of the subtree at point-or-marker POM.
  if POM is nil, refer to the entry at point. The function returns
  the number of days before deadline"
    (interactive)
    (let ((ts-ddl (org-entry-get pom "DEADLINE" nil))
          (ts-shed (org-entry-get pom "SCHEDULED" nil))
          (ndays-bef nil))
      (when (or ts-ddl ts-shed)
        (setq ndays-bef (org-time-stamp-to-now (or ts-ddl ts-shed))))
      (when ndays-bef
        ;; when entry is done, set NDAYS to 0
        (if (org-entry-is-done-p)
            (org-entry-put pom "NDAYS" (number-to-string 0))
          ;; otherwise, set the correct number
          (org-entry-put pom "NDAYS" (number-to-string ndays-bef))))))

  (defun mel/org-subtree-get-days-before-ddl (&optional pom)
    "update NDAYS property for the subtree"
    (interactive)
    (org-map-entries
     ;; func
     #'mel/org-get-days-before-ddl
     ;; match
     t
     ;; scope
     'tree))

  ;; bind keys
  (define-key org-mode-map (kbd "C-c u") 'mel/org-subtree-get-days-before-ddl)
#+end_src

* [2021-08-05 Thu 11:31] 使用 ibuffer 代替 buff-menu

  bind "C-x C-b" to ~ibuffer~ instead of using ~buff-menu~. ibuffer mode
  basic operation consists of marking, filtering and sorting. you can hit
  'h' key in `ibuffer-mode' to get more operation information.

  #+begin_src emacs-lisp :noweb-ref cfg-built-in

    ;; use `ibuffer' instead of `buff-menu'
    (use-package ibuffer
      :bind (([remap list-buffers] . ibuffer)))
  #+end_src

* [2021-08-20 Fri 10:56] 使用 org-habits
  :PROPERTIES:
  :ID:       node-2021-08-20-10-56
  :END:

~org-habit-graph-column~ 可以设置 consistency graph 在 org agenda view 中的
列位置，这个值默认是 40 ，就是说，headline 如果超过 40 个字符的话，会被
consistency graph 给盖住，这里把它改成 1 个字符（改成 0 个字符会导致无法使
用 org-agenda command，提示 command not allowed in this line），并减少显示
天数，把 consistency graph 放到任务条左边。habit 中不要添加 timestamp，
headline 最好简洁明了。

#+begin_src emacs-lisp :noweb-ref org-config

  ;; activate org-habits
  (add-to-list 'org-modules 'org-habit t)
  ;; absolute column position at which to draw the habit consistency graphs.
  (setq org-habit-graph-column 1)
  ;; Number of days before today to appear in consistency graphs
  (setq org-habit-preceding-days 9)
  ;; Number of days after today to appear in consistency graphs
  (setq org-habit-following-days 3)
#+end_src

* [2021-08-21 Sat 09:41] dos2unix carriage returns

git diff 的时候总是会显示 carriage return (^M) 字符，使用函数 dos2unix 对文
件进行转换。
#+begin_src emacs-lisp :noweb-ref pref

  ;; convert end of line character
  (defun dos2unix ()
    "convert end of line to dst-sys"
    (interactive)
    (set-buffer-file-coding-system 'undecided-unix 't))
#+end_src

* <2022-01-16 Wed 17:22> save place between sessions
save place between sessions. ref to [[https://www.emacswiki.org/emacs/SavePlace][save place on emacs wiki]].

  #+begin_src emacs-lisp :noweb-ref cfg-built-in

    ;; save file position between sessions. save-place-file is handled in
    ;; no-littering. for emacs version 25.1 and newer, use (save-place-mode 1)
    (setq save-place-forget-unreadable-files nil)
    (if (fboundp #'save-place-mode)
        (save-place-mode 1)
      (setq-default save-place t))
  #+end_src

* <2022-02-22 Tue 19:37> 将 'C-.' 改为 'C-x m' 作为 read-only-mode 的快捷键

emacs 中原先 'C-x m' 被用来调用 `compose-mail'.

#+begin_src emacs-lisp :noweb-ref pref-ro

  ;; bind Ctrl-. to toggle read-only-mode
  (global-set-key (kbd "C-x m") #'read-only-mode)

  ;; set current visiting file to read-only-mode
  (defun mel-set-buf-ro ()
    (if (and (buffer-file-name) (not (bound-and-true-p read-only-mode)))
        (read-only-mode 1)))

  ;; run command when emacs is idle for 30 secs
  (run-with-idle-timer 30 t 'mel-set-buf-ro)
#+end_src
** ref
- [[id:node-2021-07-21-17-10-00-000000][添加 "C-." 作为 read-only-mode 的快捷键]]
* <2022-04-15 Fri 09:57> 把 cfg-theme 部分移出去
  :PROPERTIES:
  :ID:       node-2022-04-15-09-57-00-000000
  :ts:       <2022-04-15 Fri 09:57>
  :END:
  zenburn-theme 是从 github 上下载的，把它统一放到 [[id:node-2021-07-09-14-29-00-000000][on-going setting]] 里去了。
* <2022-05-02 Mon 15:49> 使用 autoload 提高启动速度
  主要想法：

  - 尽量使用 autoload
  - 使用函数自动更新 autoload 文件
    + autoload 文件的更新不需要遍历 package 的每个子文件夹
    + load-path 不需要遍历 package 的每个子文件夹
  - 更新 autoload 的函数要放在 conf.el 中
  - conf.el 中加载 autoload 之后再加载 on-going.el

  遍历整个文件夹。
  #+begin_src emacs-lisp :noweb-ref autoload

    ;; search all dir containly el file under el-path
    (defun mel/search-el-dir-recursivly (el-path)
      "Get autoload-path with top dir as el-path"
      (let ((el-dirs nil))
        (if (file-directory-p el-path)
            ;; recursively goto child dir
            (dolist (entry (directory-files el-path t))
              (unless (string-match-p "\\..*$" (file-name-nondirectory entry))
                (let ((entry-dir (mel/search-el-dir-recursivly entry)))
                  (unless (null entry-dir)
                    (if (listp entry-dir)
                        (setq el-dirs (append entry-dir el-dirs))
                      (add-to-list 'el-dirs entry-dir))))))
          (when (string-match-p ".*\\.el$" el-path)
            ;; there is an elisp file in the dir, add the dir to autoload path
            (setq el-dirs (file-name-directory el-path))))
        el-dirs))
  #+end_src

  只遍历最顶层文件夹，不包含 '.' 开头的隐藏文件夹。
  #+begin_src emacs-lisp :noweb-ref autoload

    ;; walk through current dir
    (defun mel/walk-el-dir (el-path)
      "Get autoload-path with top dir as el-path"
      (let ((el-dirs nil))
        (dolist (entry (directory-files el-path t))
          (if (file-directory-p entry)
              ;; exclude dirs started with '.', but not the '.' dir
              (unless (string-match-p "\\..+$" (file-name-nondirectory entry))
                (add-to-list 'el-dirs entry))))
        el-dirs))
  #+end_src

  根据输入的 el-paths 列表，在 pkgs/non-elpa 下生成 autoload.el 文件
  #+begin_src emacs-lisp :noweb-ref autoload

    ;; generate autoload file
    (defun mel/gen-autoload-file (&optional el-paths)
      "Generate autoload files recursively in the dir list `el-paths'"
      (eval-and-compile
        (require 'autoload)
        (require 'bytecomp))
      (let (
            ;; Don't bother me.
            (inhibit-message t)
            ;; Prevent `update-directory-autoloads' from running hooks when
            ;; visiting the autoload file.
            (find-file-hook nil)
            (write-file-functions nil)
            ;; Prevent `update-directory-autoloads' from creating backup files.
            (backup-inhibited t)
            (version-control 'never)
            ;; set autoload-file
            (generated-autoload-file (mel/expand-non-elpa-file "autoloads.el")))
        ;; rm original autoload-file
        (if (file-exists-p generated-autoload-file)
            (delete-file generated-autoload-file))
        ;; create autoload-file
        (with-current-buffer (find-file-noselect generated-autoload-file)
          ;; resolve symbol links in the `generated-autoload-file', in case
          ;; there is any symbol link in the file path.
          (insert (format ";;\n;; `generated-autoload-file': %s may be *%s*\n"
                          generated-autoload-file buffer-file-name))
          (setq generated-autoload-file buffer-file-name)
          (save-buffer))
        ;; update autoload file
        (dolist (entry (or el-paths (mel/search-el-dir-recursivly mel/non-elpa)))
          (if (and (file-exists-p entry)
                   (file-directory-p entry))
              (if (fboundp 'make-directory-autoloads)
                  (make-directory-autoloads entry generated-autoload-file)
                (and (fboundp 'update-directory-autoloads)
                     (update-directory-autoloads entry)))))
        ;; compile autoload file
        (byte-compile-file generated-autoload-file)
        ;; Load autoload file
        (load generated-autoload-file 'noerror 'nomessage)
        ;; kill autoload buf
        (when-let ((buf (find-buffer-visiting generated-autoload-file)))
          (kill-buffer buf))))
  #+end_src

  加一个更新 autoload 文件的函数。
  #+begin_src emacs-lisp :noweb-ref autoload

    ;; update autoload file
    (defun mel/update-autoload ()
      (interactive)
      (let ((el-dir (mel/walk-el-dir mel/non-elpa)))
        (mel/gen-autoload-file el-dir)))
  #+end_src

  检查 mel/non-elpa 下有没有 autoload 文件，有就加载。
  #+begin_src emacs-lisp :noweb-ref autoload

    ;; load autoload file
    (let ((mel/autoload-file (mel/expand-non-elpa-file "autoloads.el")))
      (if (file-exists-p mel/autoload-file)
          (load-file mel/autoload-file)
        (message "autoload file %s NOT FOUND. Use `mel/update-autoload' to generate one?"
                 mel/autoload-file)))
  #+end_src

** [2022-04-27 Wed 17:29] debug autoload windows 下无法生成
   问题：windows 下无法使用 mel/gen-autoload-file 函数生成 autoload 文件

   原因：autoload-generate-file-autoloads 函数内部因为 outfile 与
   autoload-generated-file 文件名不一致，导致 otherbuf 变量被设置成了 t.

** ref
   - [[https://github.com/dimitri/el-get/issues/2751][invalid time specification]]
   - [[https://emacs-china.org/t/autoload/15085/12][关于 autoload 的疑问]]
   - [[https://github.com/raxod502/straight.el#install-packages][straight.el]]
   - autoload.el -> autoload-generate-file-autoloads
   - [[https://www.emacswiki.org/emacs/UpdateAutoloads][emacs wiki - update autoload]]
   - [[https://two-wrongs.com/migrating-away-from-use-package][loading & load-path, eval-and-compile vs. eval-when-compile]]
   - [[https://emacs.stackexchange.com/questions/8023/how-to-use-autoload][SO - how to use autoload]]
   - [[https://emacs-china.org/t/autoload/15085/12][problem with autoload comments]]
   - [[https://stackoverflow.com/questions/36994731/how-autoload-works][how autoload works]]
   - [[http://xahlee.info/emacs/emacs/elisp_library_system.html][load, load-file and autoload]]
